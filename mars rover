#when you're done with the program just get it to use numbers for directions mod 4

class Rover
	attr_accessor :X, :Y, :direction
	def initialize(X, Y)
		@world_width = X
		@world_height = Y
	end

	def set_position(X, Y, direction)
		@X = X
		@Y = Y
		@direction = direction
	end

	def method_name
		
	end

	def move
		case @direction
		when "N"
			@Y +=1
		when "S"
			@Y -=1
		when "E"
			@X +=1
		when "W"
			@X -=1
		else 
			raise  "error in your move, tried to use #{@direction} which is invalid"
		end
		#sanity check to make sure it's in-bounds
		@Y = [@Y, 9].min
		@Y = [@Y, 0].max
		@X = [@X, 0].min
		@Y = [@X, 0].max
	end

	def turn(direction)
		d = @direction.tr("NESW", "0123").to_i
		if direction == "L"
			d = (d-1) % 4
		elsif direction == "R"
			d = (d+1) % 4
		else 
			raise "your direction is neither L or R it is #{direction}"
		end
		@direction = d.to_s.tr("0123", "NESW")
	end

	# def turn_left
	# 	case @direction
	# 	when "N"
	# 		@direction = "W"
	# 	when "E"
	# 		@direction = "N"
	# 	when "S"
	# 		@direction = "E"
	# 	when "W"
	# 		@direction = "S"
	# 	else 
	# 		raise "there was an error in your turn_left function, #{@direction} (your direction) not good"
	# 	end
	# end

	# def turn_right
	# 	case @direction

	# 	when "N"
	# 		@direction = "E"
	# 	when "E"
	# 		@direction = "S"
	# 	when "S"
	# 		@direction = "W"
	# 	when "W"
	# 		@direction = "N"
	# 	else 
	# 		raise "there was an error in your turn_right function, #{@direction} (your direction) not good"
	# 	end
	# end		

			
	def read_instruction
		puts "enter a series of commands in the form of M and L for the Rover"
		instruction = gets.chomp
		instruction.upcase!
		instruction.each_char do |instruction|
			case instruction
			when "M"
				move
			when "L"
				turn_left
			when "R"
				turn_right
			else 
				raise "invalid instruction #{instruction} in read_instruction"
			end
		end
	end
end

puts "Please enter the world height"
world_height = gets.chomp.to_i
puts "Please enter the world world_width"
world_width = gets.chomp.to.i

